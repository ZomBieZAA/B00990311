import{v as A,M as S,_ as I,w as E,x as M,y as R,z as N,J as B,N as k,O as P,Q as F,V as O,X as C,Y as D,Z as W,$ as K,a0 as w}from"./index-a0afce76.js";class Y{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(e,t,i,n){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=t,this._target=e,this._scene=i,this._host=n,this._activeTargets=[],t._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===A.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=S.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,this._minFrame!==0){const a={frame:0,value:this._minValue};this._keys.splice(0,0,a)}if(this._target instanceof Array){let a=0;for(const r of this._target)this._preparePath(r,a),this._getOriginalValues(a),a++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const s=t.getEvents();s&&s.length>0&&s.forEach(a=>{this._events.push(a._clone())}),this._enableBlending=e&&e.animationPropertiesOverride?e.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(e,t=0){const i=this._animation.targetPropertyPath;if(i.length>1){let n=e;for(let s=0;s<i.length-1;s++){const a=i[s];if(n=n[a],n===void 0)throw new Error(`Invalid property (${a}) in property path (${i.join(".")})`)}this._targetPath=i[i.length-1],this._activeTargets[t]=n}else this._targetPath=i[0],this._activeTargets[t]=e;if(this._activeTargets[t][this._targetPath]===void 0)throw new Error(`Invalid property (${this._targetPath}) in property path (${i.join(".")})`)}get animation(){return this._animation}reset(e=!1){if(e)if(this._target instanceof Array){let t=0;for(const i of this._target)this._originalValue[t]!==void 0&&this._setValue(i,this._activeTargets[t],this._originalValue[t],-1,t),t++}else this._originalValue[0]!==void 0&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let t=0;t<this._events.length;t++)this._events[t].isDone=!1}isStopped(){return this._stopped}dispose(){const e=this._animation.runtimeAnimations.indexOf(this);e>-1&&this._animation.runtimeAnimations.splice(e,1)}setValue(e,t){if(this._targetIsArray){for(let i=0;i<this._target.length;i++){const n=this._target[i];this._setValue(n,this._activeTargets[i],e,t,i)}return}this._setValue(this._target,this._directTarget,e,t,0)}_getOriginalValues(e=0){let t;const i=this._activeTargets[e];i.getLocalMatrix&&this._targetPath==="_matrix"?t=i.getLocalMatrix():t=i[this._targetPath],t&&t.clone?this._originalValue[e]=t.clone():this._originalValue[e]=t}_registerTargetForLateAnimationBinding(e,t){const i=e.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(i),i._lateAnimationHolders||(i._lateAnimationHolders={}),i._lateAnimationHolders[e.targetPath]||(i._lateAnimationHolders[e.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:t}),e.isAdditive?(i._lateAnimationHolders[e.targetPath].additiveAnimations.push(e),i._lateAnimationHolders[e.targetPath].totalAdditiveWeight+=e.weight):(i._lateAnimationHolders[e.targetPath].animations.push(e),i._lateAnimationHolders[e.targetPath].totalWeight+=e.weight)}_setValue(e,t,i,n,s){if(this._currentActiveTarget=t,this._weight=n,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const r=t[this._targetPath];r.clone?this._originalBlendValue=r.clone():this._originalBlendValue=r}this._originalBlendValue.m?A.AllowMatrixDecomposeForInterpolation?this._currentValue?S.DecomposeLerpToRef(this._originalBlendValue,i,this._blendingFactor,this._currentValue):this._currentValue=S.DecomposeLerp(this._originalBlendValue,i,this._blendingFactor):this._currentValue?S.LerpToRef(this._originalBlendValue,i,this._blendingFactor,this._currentValue):this._currentValue=S.Lerp(this._originalBlendValue,i,this._blendingFactor):this._currentValue=A._UniversalLerp(this._originalBlendValue,i,this._blendingFactor);const a=e&&e.animationPropertiesOverride?e.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=a}else this._currentValue?this._currentValue.copyFrom?this._currentValue.copyFrom(i):this._currentValue=i:i?.clone?this._currentValue=i.clone():this._currentValue=i;n!==-1?this._registerTargetForLateAnimationBinding(this,this._originalValue[s]):this._animationState.loopMode===A.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[s],t[this._targetPath]):t[this._targetPath]=this._originalValue[s]+this._currentValue:t[this._targetPath]=this._currentValue,e.markAsDirty&&e.markAsDirty(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(e,t=-1){const i=this._animation.getKeys();e<i[0].frame?e=i[0].frame:e>i[i.length-1].frame&&(e=i[i.length-1].frame);const n=this._events;if(n.length)for(let a=0;a<n.length;a++)n[a].onlyOnce||(n[a].isDone=n[a].frame<e);this._currentFrame=e;const s=this._animation._interpolate(e,this._animationState);this.setValue(s,t)}_prepareForSpeedRatioChange(e){const t=this._previousElapsedTime*(this._animation.framePerSecond*e)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-t}animate(e,t,i,n,s,a=-1){const r=this._animation,o=r.targetPropertyPath;if(!o||o.length<1)return this._stopped=!0,!1;let l=!0;(t<this._minFrame||t>this._maxFrame)&&(t=this._minFrame),(i<this._minFrame||i>this._maxFrame)&&(i=this._maxFrame);const m=i-t;let c,g=e*(r.framePerSecond*s)/1e3+this._absoluteFrameOffset,_=0,d=!1;const u=n&&this._animationState.loopMode===A.ANIMATIONLOOPMODE_YOYO;if(u){const f=(g-t)/m,b=Math.sin(f*Math.PI);g=Math.abs(b)*m+t;const L=b>=0?1:-1;this._yoyoDirection!==L&&(d=!0),this._yoyoDirection=L}if(this._previousElapsedTime=e,this._previousAbsoluteFrame=g,!n&&i>=t&&(g>=m&&s>0||g<=0&&s<0))l=!1,_=r._getKeyValue(this._maxValue);else if(!n&&t>=i&&(g<=m&&s<0||g>=0&&s>0))l=!1,_=r._getKeyValue(this._minValue);else if(this._animationState.loopMode!==A.ANIMATIONLOOPMODE_CYCLE){const f=i.toString()+t.toString();if(!this._offsetsCache[f]){this._animationState.repeatCount=0,this._animationState.loopMode=A.ANIMATIONLOOPMODE_CYCLE;const b=r._interpolate(t,this._animationState),T=r._interpolate(i,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),r.dataType){case A.ANIMATIONTYPE_FLOAT:this._offsetsCache[f]=T-b;break;case A.ANIMATIONTYPE_QUATERNION:this._offsetsCache[f]=T.subtract(b);break;case A.ANIMATIONTYPE_VECTOR3:this._offsetsCache[f]=T.subtract(b);break;case A.ANIMATIONTYPE_VECTOR2:this._offsetsCache[f]=T.subtract(b);break;case A.ANIMATIONTYPE_SIZE:this._offsetsCache[f]=T.subtract(b);break;case A.ANIMATIONTYPE_COLOR3:this._offsetsCache[f]=T.subtract(b);break}this._highLimitsCache[f]=T}_=this._highLimitsCache[f],c=this._offsetsCache[f]}if(c===void 0)switch(r.dataType){case A.ANIMATIONTYPE_FLOAT:c=0;break;case A.ANIMATIONTYPE_QUATERNION:c=B;break;case A.ANIMATIONTYPE_VECTOR3:c=N;break;case A.ANIMATIONTYPE_VECTOR2:c=R;break;case A.ANIMATIONTYPE_SIZE:c=M;break;case A.ANIMATIONTYPE_COLOR3:c=E;break;case A.ANIMATIONTYPE_COLOR4:c=I;break}let p;if(this._host&&this._host.syncRoot){const f=this._host.syncRoot,b=(f.masterFrame-f.fromFrame)/(f.toFrame-f.fromFrame);p=t+m*b}else g>0&&t>i||g<0&&t<i?p=l&&m!==0?i+g%m:t:p=l&&m!==0?t+g%m:i;const y=this._events;if(!u&&(s>0&&this.currentFrame>p||s<0&&this.currentFrame<p)||u&&d){this._onLoop();for(let f=0;f<y.length;f++)y[f].onlyOnce||(y[f].isDone=!1);this._animationState.key=s>0?0:r.getKeys().length-1}this._currentFrame=p,this._animationState.repeatCount=m===0?0:g/m>>0,this._animationState.highLimitValue=_,this._animationState.offsetValue=c;const v=r._interpolate(p,this._animationState);if(this.setValue(v,a),y.length){for(let f=0;f<y.length;f++)if(m>=0&&p>=y[f].frame&&y[f].frame>=t||m<0&&p<=y[f].frame&&y[f].frame<=t){const b=y[f];b.isDone||(b.onlyOnce&&(y.splice(f,1),f--),b.isDone=!0,b.action(p))}}return l||(this._stopped=!0),l}}class x{get syncRoot(){return this._syncRoot}get masterFrame(){return this._runtimeAnimations.length===0?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(e){if(e===-1){this._weight=-1;return}this._weight=Math.min(Math.max(e,0),1)}get speedRatio(){return this._speedRatio}set speedRatio(e){for(let t=0;t<this._runtimeAnimations.length;t++)this._runtimeAnimations[t]._prepareForSpeedRatioChange(e);this._speedRatio=e,this._goToFrame!==null&&this.goToFrame(this._goToFrame)}get elapsedTime(){return this._localDelayOffset===null?0:this._scene._animationTime-this._localDelayOffset}constructor(e,t,i=0,n=100,s=!1,a=1,r,o,l,m=!1,c=0){this.target=t,this.fromFrame=i,this.toFrame=n,this.loopAnimation=s,this.onAnimationEnd=r,this.onAnimationLoop=l,this.isAdditive=m,this.playOrder=c,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this._paused=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new P,this.onAnimationLoopObservable=new P,this._scene=e,o&&this.appendAnimations(t,o),this._speedRatio=a,e._activeAnimatables.push(this)}syncWith(e){if(this._syncRoot=e,e){const t=this._scene._activeAnimatables.indexOf(this);t>-1&&(this._scene._activeAnimatables.splice(t,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(e,t){for(let i=0;i<t.length;i++){const n=t[i],s=new Y(e,n,this._scene,this);s._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(s)}}getAnimationByTargetProperty(e){const t=this._runtimeAnimations;for(let i=0;i<t.length;i++)if(t[i].animation.targetProperty===e)return t[i].animation;return null}getRuntimeAnimationByTargetProperty(e){const t=this._runtimeAnimations;for(let i=0;i<t.length;i++)if(t[i].animation.targetProperty===e)return t[i];return null}reset(){const e=this._runtimeAnimations;for(let t=0;t<e.length;t++)e[t].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(e){const t=this._runtimeAnimations;for(let i=0;i<t.length;i++)t[i].animation.enableBlending=!0,t[i].animation.blendingSpeed=e}disableBlending(){const e=this._runtimeAnimations;for(let t=0;t<e.length;t++)e[t].animation.enableBlending=!1}goToFrame(e){const t=this._runtimeAnimations;if(t[0]){const i=t[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??t[0].currentFrame;const n=this.speedRatio===0?0:(e-this._frameToSyncFromJump)/i*1e3/this.speedRatio;this._manualJumpDelay=-n}for(let i=0;i<t.length;i++)t[i].goToFrame(e,this._weight);this._goToFrame=e}get paused(){return this._paused}pause(){this._paused||(this._paused=!0)}restart(){this._paused=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(e,t,i=!1,n=!1){if(e||t){const s=this._scene._activeAnimatables.indexOf(this);if(s>-1){const a=this._runtimeAnimations;for(let r=a.length-1;r>=0;r--){const o=a[r];e&&o.animation.name!=e||t&&!t(o.target)||(o.dispose(),a.splice(r,1))}a.length==0&&(i||this._scene._activeAnimatables.splice(s,1),n||this._raiseOnAnimationEnd())}}else{const s=this._scene._activeAnimatables.indexOf(this);if(s>-1){i||this._scene._activeAnimatables.splice(s,1);const a=this._runtimeAnimations;for(let r=0;r<a.length;r++)a[r].dispose();this._runtimeAnimations.length=0,n||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise(e=>{this.onAnimationEndObservable.add(()=>{e(this)},void 0,void 0,this,!0)})}_animate(e){if(this._paused)return this.animationStarted=!1,this._pausedDelay===null&&(this._pausedDelay=e),!0;if(this._localDelayOffset===null?(this._localDelayOffset=e,this._pausedDelay=null):this._pausedDelay!==null&&(this._localDelayOffset+=e-this._pausedDelay,this._pausedDelay=null),this._manualJumpDelay!==null&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,this._weight===0)return!0;let t=!1;const i=this._runtimeAnimations;let n;for(n=0;n<i.length;n++){const a=i[n].animate(e-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);t=t||a}if(this.animationStarted=t,!t){if(this.disposeOnEnd)for(n=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(n,1),n=0;n<i.length;n++)i[n].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return t}}function U(h){if(h.totalWeight===0&&h.totalAdditiveWeight===0)return h.originalValue;let e=1;const t=O.Vector3[0],i=O.Vector3[1],n=O.Quaternion[0];let s=0;const a=h.animations[0],r=h.originalValue;let o=1,l=!1;if(h.totalWeight<1)o=1-h.totalWeight,r.decompose(i,n,t);else{if(s=1,e=h.totalWeight,o=a.weight/e,o==1)if(h.totalAdditiveWeight)l=!0;else return a.currentValue;a.currentValue.decompose(i,n,t)}if(!l){i.scaleInPlace(o),t.scaleInPlace(o),n.scaleInPlace(o);for(let c=s;c<h.animations.length;c++){const g=h.animations[c];if(g.weight===0)continue;o=g.weight/e;const _=O.Vector3[2],d=O.Vector3[3],u=O.Quaternion[1];g.currentValue.decompose(d,u,_),d.scaleAndAddToRef(o,i),u.scaleAndAddToRef(F.Dot(n,u)>0?o:-o,n),_.scaleAndAddToRef(o,t)}n.normalize()}for(let c=0;c<h.additiveAnimations.length;c++){const g=h.additiveAnimations[c];if(g.weight===0)continue;const _=O.Vector3[2],d=O.Vector3[3],u=O.Quaternion[1];g.currentValue.decompose(d,u,_),d.multiplyToRef(i,d),C.LerpToRef(i,d,g.weight,i),n.multiplyToRef(u,u),F.SlerpToRef(n,u,g.weight,n),_.scaleAndAddToRef(g.weight,t)}const m=a?a._animationState.workValue:O.Matrix[0].clone();return S.ComposeToRef(i,n,t,m),m}function z(h,e){if(h.totalWeight===0&&h.totalAdditiveWeight===0)return e;const t=h.animations[0],i=h.originalValue;let n=e;if(h.totalWeight===0&&h.totalAdditiveWeight>0)n.copyFrom(i);else if(h.animations.length===1){if(F.SlerpToRef(i,t.currentValue,Math.min(1,h.totalWeight),n),h.totalAdditiveWeight===0)return n}else if(h.animations.length>1){let s=1,a,r;if(h.totalWeight<1){const l=1-h.totalWeight;a=[],r=[],a.push(i),r.push(l)}else{if(h.animations.length===2&&(F.SlerpToRef(h.animations[0].currentValue,h.animations[1].currentValue,h.animations[1].weight/h.totalWeight,e),h.totalAdditiveWeight===0))return e;a=[],r=[],s=h.totalWeight}for(let l=0;l<h.animations.length;l++){const m=h.animations[l];a.push(m.currentValue),r.push(m.weight/s)}let o=0;for(let l=0;l<a.length;){if(!l){F.SlerpToRef(a[l],a[l+1],r[l+1]/(r[l]+r[l+1]),e),n=e,o=r[l]+r[l+1],l+=2;continue}o+=r[l],F.SlerpToRef(n,a[l],r[l]/o,n),l++}}for(let s=0;s<h.additiveAnimations.length;s++){const a=h.additiveAnimations[s];a.weight!==0&&(n.multiplyToRef(a.currentValue,O.Quaternion[0]),F.SlerpToRef(n,O.Quaternion[0],a.weight,n))}return n}function H(h){if(h._registeredForLateAnimationBindings.length){for(let e=0;e<h._registeredForLateAnimationBindings.length;e++){const t=h._registeredForLateAnimationBindings.data[e];for(const i in t._lateAnimationHolders){const n=t._lateAnimationHolders[i],s=n.animations[0],a=n.originalValue;if(a==null)continue;const r=A.AllowMatrixDecomposeForInterpolation&&a.m;let o=t[i];if(r)o=U(n);else if(a.w!==void 0)o=z(n,o||F.Identity());else{let m=0,c=1;const g=s&&s._animationState.loopMode===A.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(n.totalWeight<1)g?o=a.clone?a.clone():a:s&&a.scale?o=a.scale(1-n.totalWeight):s?o=a*(1-n.totalWeight):a.clone?o=a.clone():o=a;else if(s){c=n.totalWeight;const _=s.weight/c;_!==1?s.currentValue.scale?o=s.currentValue.scale(_):o=s.currentValue*_:o=s.currentValue,g&&(o.addToRef?o.addToRef(a,o):o+=a),m=1}for(let _=m;_<n.animations.length;_++){const d=n.animations[_],u=d.weight/c;if(u)d.currentValue.scaleAndAddToRef?d.currentValue.scaleAndAddToRef(u,o):o+=d.currentValue*u;else continue}for(let _=0;_<n.additiveAnimations.length;_++){const d=n.additiveAnimations[_],u=d.weight;if(u)d.currentValue.scaleAndAddToRef?d.currentValue.scaleAndAddToRef(u,o):o+=d.currentValue*u;else continue}}t[i]=o}t._lateAnimationHolders={}}h._registeredForLateAnimationBindings.reset()}}function X(h,e){e&&(e.prototype.copyAnimationRange=function(t,i,n,s=!1,a=null){this.animations.length===0&&(this.animations.push(new A(this.name,"_matrix",t.animations[0].framePerSecond,A.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const r=t.animations[0].getRange(i);if(!r)return!1;const o=r.from,l=r.to,m=t.animations[0].getKeys(),c=t.length,g=t.getParent(),_=this.getParent(),d=s&&g&&c&&this.length&&c!==this.length,u=d&&_&&g?_.length/g.length:1,p=s&&!_&&a&&(a.x!==1||a.y!==1||a.z!==1),y=this.animations[0].getKeys();let v,f,b;for(let T=0,L=m.length;T<L;T++)v=m[T],v.frame>=o&&v.frame<=l&&(s?(b=v.value.clone(),d?(f=b.getTranslation(),b.setTranslation(f.scaleInPlace(u))):p&&a?(f=b.getTranslation(),b.setTranslation(f.multiplyInPlace(a))):b=v.value):b=v.value,y.push({frame:v.frame+n,value:b}));return this.animations[0].createRange(i,o+n,l+n),!0}),h&&(h.prototype._animate=function(t){if(!this.animationsEnabled)return;const i=k.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=i}this.deltaTime=t!==void 0?t:this.useConstantAnimationDeltaTime?16:(i-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=i;const n=this._activeAnimatables;if(n.length===0)return;this._animationTime+=this.deltaTime;const s=this._animationTime;for(let a=0;a<n.length;a++){const r=n[a];!r._animate(s)&&r.disposeOnEnd&&a--}H(this)},h.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort((t,i)=>t.playOrder-i.playOrder)},h.prototype.beginWeightedAnimation=function(t,i,n,s=1,a,r=1,o,l,m,c,g=!1){const _=this.beginAnimation(t,i,n,a,r,o,l,!1,m,c,g);return _.weight=s,_},h.prototype.beginAnimation=function(t,i,n,s,a=1,r,o,l=!0,m,c,g=!1){if(a<0){const d=i;i=n,n=d,a=-a}i>n&&(a=-a),l&&this.stopAnimation(t,void 0,m),o||(o=new x(this,t,i,n,s,a,r,void 0,c,g));const _=m?m(t):!0;if(t.animations&&_&&o.appendAnimations(t,t.animations),t.getAnimatables){const d=t.getAnimatables();for(let u=0;u<d.length;u++)this.beginAnimation(d[u],i,n,s,a,r,o,l,m,c)}return o.reset(),o},h.prototype.beginHierarchyAnimation=function(t,i,n,s,a,r=1,o,l,m=!0,c,g,_=!1){const d=t.getDescendants(i),u=[];u.push(this.beginAnimation(t,n,s,a,r,o,l,m,c,void 0,_));for(const p of d)u.push(this.beginAnimation(p,n,s,a,r,o,l,m,c,void 0,_));return u},h.prototype.beginDirectAnimation=function(t,i,n,s,a,r=1,o,l,m=!1){if(r<0){const g=n;n=s,s=g,r=-r}return n>s&&(r=-r),new x(this,t,n,s,a,r,o,i,l,m)},h.prototype.beginDirectHierarchyAnimation=function(t,i,n,s,a,r,o,l,m,c=!1){const g=t.getDescendants(i),_=[];_.push(this.beginDirectAnimation(t,n,s,a,r,o,l,m,c));for(const d of g)_.push(this.beginDirectAnimation(d,n,s,a,r,o,l,m,c));return _},h.prototype.getAnimatableByTarget=function(t){for(let i=0;i<this._activeAnimatables.length;i++)if(this._activeAnimatables[i].target===t)return this._activeAnimatables[i];return null},h.prototype.getAllAnimatablesByTarget=function(t){const i=[];for(let n=0;n<this._activeAnimatables.length;n++)this._activeAnimatables[n].target===t&&i.push(this._activeAnimatables[n]);return i},h.prototype.stopAnimation=function(t,i,n){const s=this.getAllAnimatablesByTarget(t);for(const a of s)a.stop(i,n)},h.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let t=0;t<this._activeAnimatables.length;t++)this._activeAnimatables[t].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const t of this.animationGroups)t.stop()})}X(W,D);class J{getClassName(){return"TargetedAnimation"}serialize(){const e={};return e.animation=this.animation.serialize(),e.targetId=this.target.id,e}}class V{get mask(){return this._mask}set mask(e){this._mask!==e&&(this._mask=e,this.syncWithMask(!0))}syncWithMask(e=!1){if(!this.mask&&!e){this._numActiveAnimatables=this._targetedAnimations.length;return}this._numActiveAnimatables=0;for(let t=0;t<this._animatables.length;++t){const i=this._animatables[t];!this.mask||this.mask.disabled||this.mask.retainsTarget(i.target.name)?(this._numActiveAnimatables++,i.paused&&i.restart()):i.paused||i.pause()}}removeUnmaskedAnimations(){if(!(!this.mask||this.mask.disabled)){for(let e=0;e<this._animatables.length;++e){const t=this._animatables[e];this.mask.retainsTarget(t.target.name)||(t.stop(),this._animatables.splice(e,1),--e)}for(let e=0;e<this._targetedAnimations.length;e++){const t=this._targetedAnimations[e];this.mask.retainsTarget(t.target.name)||(this._targetedAnimations.splice(e,1),--e)}}}get from(){return this._from}set from(e){if(this._from!==e){this._from=e;for(let t=0;t<this._animatables.length;t++){const i=this._animatables[t];i.fromFrame=this._from}}}get to(){return this._to}set to(e){if(this._to!==e){this._to=e;for(let t=0;t<this._animatables.length;t++){const i=this._animatables[t];i.toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(e){if(this._speedRatio!==e){this._speedRatio=e;for(let t=0;t<this._animatables.length;t++){const i=this._animatables[t];i.speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(e){if(this._loopAnimation!==e){this._loopAnimation=e;for(let t=0;t<this._animatables.length;t++){const i=this._animatables[t];i.loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(e){if(this._isAdditive!==e){this._isAdditive=e;for(let t=0;t<this._animatables.length;t++){const i=this._animatables[t];i.isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(e){this._weight!==e&&(this._weight=e,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(e){if(this._playOrder!==e&&(this._playOrder=e,this._animatables.length>0)){for(let t=0;t<this._animatables.length;t++)this._animatables[t].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(e){if(this._enableBlending!==e&&(this._enableBlending=e,e!==null))for(let t=0;t<this._targetedAnimations.length;++t)this._targetedAnimations[t].animation.enableBlending=e}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(e){if(this._blendingSpeed!==e&&(this._blendingSpeed=e,e!==null))for(let t=0;t<this._targetedAnimations.length;++t)this._targetedAnimations[t].animation.blendingSpeed=e}getLength(e,t){e=e??this._from,t=t??this._to;const i=this.targetedAnimations[0].animation.framePerSecond*this._speedRatio;return(t-e)/i}static MergeAnimationGroups(e,t=!0,i=!1,n){if(e.length===0)return null;n=n??e[0].weight;let s=Number.MAX_VALUE,a=-Number.MAX_VALUE;if(i)for(const o of e)o.from<s&&(s=o.from),o.to>a&&(a=o.to);const r=new V(e[0].name+"_merged",e[0]._scene,n);for(const o of e){i&&o.normalize(s,a);for(const l of o.targetedAnimations)r.addTargetedAnimation(l.animation,l.target);t&&o.dispose()}return r}constructor(e,t=null,i=-1,n=0){this.name=e,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new P,this.onAnimationLoopObservable=new P,this.onAnimationGroupLoopObservable=new P,this.onAnimationGroupEndObservable=new P,this.onAnimationGroupPauseObservable=new P,this.onAnimationGroupPlayObservable=new P,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=t||K.LastCreatedScene,this._weight=i,this._playOrder=n,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(e,t){const i=new J;i.animation=e,i.target=t;const n=e.getKeys();return this._from>n[0].frame&&(this._from=n[0].frame),this._to<n[n.length-1].frame&&(this._to=n[n.length-1].frame),this._enableBlending!==null&&(e.enableBlending=this._enableBlending),this._blendingSpeed!==null&&(e.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(i),this._shouldStart=!0,i}removeTargetedAnimation(e){for(let t=this._targetedAnimations.length-1;t>-1;t--)this._targetedAnimations[t].animation===e&&this._targetedAnimations.splice(t,1)}normalize(e=null,t=null){e==null&&(e=this._from),t==null&&(t=this._to);for(let i=0;i<this._targetedAnimations.length;i++){const s=this._targetedAnimations[i].animation.getKeys(),a=s[0],r=s[s.length-1];if(a.frame>e){const o={frame:e,value:a.value,inTangent:a.inTangent,outTangent:a.outTangent,interpolation:a.interpolation};s.splice(0,0,o)}if(r.frame<t){const o={frame:t,value:r.value,inTangent:r.inTangent,outTangent:r.outTangent,interpolation:r.interpolation};s.push(o)}}return this._from=e,this._to=t,this}_processLoop(e,t,i){e.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(t),!this._animationLoopFlags[i]&&(this._animationLoopFlags[i]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(e=!1,t=1,i,n,s){if(this._isStarted||this._targetedAnimations.length===0)return this;this._loopAnimation=e,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let a=0;a<this._targetedAnimations.length;a++){const r=this._targetedAnimations[a],o=this._scene.beginDirectAnimation(r.target,[r.animation],i!==void 0?i:this._from,n!==void 0?n:this._to,e,t,void 0,void 0,s!==void 0?s:this._isAdditive);o.weight=this._weight,o.playOrder=this._playOrder,o.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(r),this._checkAnimationGroupEnded(o)},this._processLoop(o,r,a),this._animatables.push(o)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=t,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let e=0;e<this._animatables.length;e++)this._animatables[e].pause();return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(e){return this.isStarted&&this._animatables.length&&!this._shouldStart?(e!==void 0&&(this.loopAnimation=e),this.restart()):(this.stop(),this.start(e,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let e=0;e<this._animatables.length;e++)this._animatables[e].reset();return this}restart(){if(!this._isStarted)return this;for(let e=0;e<this._animatables.length;e++)this._animatables[e].restart();return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(e=!1){if(!this._isStarted)return this;const t=this._animatables.slice();for(let n=0;n<t.length;n++)t[n].stop(void 0,void 0,!0,e);let i=0;for(let n=0;n<this._scene._activeAnimatables.length;n++){const s=this._scene._activeAnimatables[n];s._runtimeAnimations.length>0?this._scene._activeAnimatables[i++]=s:e&&this._checkAnimationGroupEnded(s,e)}return this._scene._activeAnimatables.length=i,this._isStarted=!1,this}setWeightForAllAnimatables(e){for(let t=0;t<this._animatables.length;t++){const i=this._animatables[t];i.weight=e}return this}syncAllAnimationsWith(e){for(let t=0;t<this._animatables.length;t++)this._animatables[t].syncWith(e);return this}goToFrame(e){if(!this._isStarted)return this;for(let t=0;t<this._animatables.length;t++)this._animatables[t].goToFrame(e);return this}getCurrentFrame(){return this.animatables[0]?.masterFrame||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const e=this._scene.animationGroups.indexOf(this);if(e>-1&&this._scene.animationGroups.splice(e,1),this._parentContainer){const t=this._parentContainer.animationGroups.indexOf(this);t>-1&&this._parentContainer.animationGroups.splice(t,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(e,t=!1){const i=this._animatables.indexOf(e);i>-1&&this._animatables.splice(i,1),this._animatables.length===0&&(this._isStarted=!1,t||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(e,t,i=!1){const n=new V(e||this.name,this._scene,this._weight,this._playOrder);n._from=this.from,n._to=this.to,n._speedRatio=this.speedRatio,n._loopAnimation=this.loopAnimation,n._isAdditive=this.isAdditive,n._enableBlending=this.enableBlending,n._blendingSpeed=this.blendingSpeed,n.metadata=this.metadata,n.mask=this.mask;for(const s of this._targetedAnimations)n.addTargetedAnimation(i?s.animation.clone():s.animation,t?t(s.target):s.target);return n}serialize(){const e={};e.name=this.name,e.from=this.from,e.to=this.to,e.speedRatio=this.speedRatio,e.loopAnimation=this.loopAnimation,e.isAdditive=this.isAdditive,e.weight=this.weight,e.playOrder=this.playOrder,e.enableBlending=this.enableBlending,e.blendingSpeed=this.blendingSpeed,e.targetedAnimations=[];for(let t=0;t<this.targetedAnimations.length;t++){const i=this.targetedAnimations[t];e.targetedAnimations[t]=i.serialize()}return w&&w.HasTags(this)&&(e.tags=w.GetTags(this)),this.metadata&&(e.metadata=this.metadata),e}static Parse(e,t){const i=new V(e.name,t,e.weight,e.playOrder);for(let n=0;n<e.targetedAnimations.length;n++){const s=e.targetedAnimations[n],a=A.Parse(s.animation),r=s.targetId;if(s.animation.property==="influence"){const o=t.getMorphTargetById(r);o&&i.addTargetedAnimation(a,o)}else{const o=t.getNodeById(r);o!=null&&i.addTargetedAnimation(a,o)}}return w&&w.AddTagsTo(i,e.tags),e.from!==null&&e.to!==null&&i.normalize(e.from,e.to),e.speedRatio!==void 0&&(i._speedRatio=e.speedRatio),e.loopAnimation!==void 0&&(i._loopAnimation=e.loopAnimation),e.isAdditive!==void 0&&(i._isAdditive=e.isAdditive),e.weight!==void 0&&(i._weight=e.weight),e.playOrder!==void 0&&(i._playOrder=e.playOrder),e.enableBlending!==void 0&&(i._enableBlending=e.enableBlending),e.blendingSpeed!==void 0&&(i._blendingSpeed=e.blendingSpeed),e.metadata!==void 0&&(i.metadata=e.metadata),i}static MakeAnimationAdditive(e,t,i,n=!1,s){let a;typeof t=="object"?a=t:a={referenceFrame:t,range:i,cloneOriginalAnimationGroup:n,clonedAnimationName:s};let r=e;a.cloneOriginalAnimationGroup&&(r=e.clone(a.clonedAnimationGroupName||r.name));const o=r.targetedAnimations;for(let l=0;l<o.length;l++){const m=o[l];m.animation=A.MakeAnimationAdditive(m.animation,a)}if(r.isAdditive=!0,a.clipKeys){let l=Number.MAX_VALUE,m=-Number.MAX_VALUE;const c=r.targetedAnimations;for(let g=0;g<c.length;g++){const u=c[g].animation.getKeys();l>u[0].frame&&(l=u[0].frame),m<u[u.length-1].frame&&(m=u[u.length-1].frame)}r._from=l,r._to=m}return r}static ClipKeys(e,t,i,n,s){const a=e.clone(n||e.name);return V.ClipKeysInPlace(a,t,i,s)}static ClipKeysInPlace(e,t,i,n){return V.ClipInPlace(e,t,i,n,!1)}static ClipFrames(e,t,i,n,s){const a=e.clone(n||e.name);return V.ClipFramesInPlace(a,t,i,s)}static ClipFramesInPlace(e,t,i,n){return V.ClipInPlace(e,t,i,n,!0)}static ClipInPlace(e,t,i,n,s=!1){let a=Number.MAX_VALUE,r=-Number.MAX_VALUE;const o=e.targetedAnimations;for(let l=0;l<o.length;l++){const m=o[l],c=n?m.animation:m.animation.clone();s&&(c.createKeyForFrame(t),c.createKeyForFrame(i));const g=c.getKeys(),_=[];let d=Number.MAX_VALUE;for(let u=0;u<g.length;u++){const p=g[u];if(!s&&u>=t&&u<=i||s&&p.frame>=t&&p.frame<=i){const y={frame:p.frame,value:p.value.clone?p.value.clone():p.value,inTangent:p.inTangent,outTangent:p.outTangent,interpolation:p.interpolation,lockedTangent:p.lockedTangent};d===Number.MAX_VALUE&&(d=y.frame),y.frame-=d,_.push(y)}}if(_.length===0){o.splice(l,1),l--;continue}a>_[0].frame&&(a=_[0].frame),r<_[_.length-1].frame&&(r=_[_.length-1].frame),c.setKeys(_,!0),m.animation=c}return e._from=a,e._to=r,e}getClassName(){return"AnimationGroup"}toString(e){let t="Name: "+this.name;return t+=", type: "+this.getClassName(),e&&(t+=", from: "+this._from,t+=", to: "+this._to,t+=", isStarted: "+this._isStarted,t+=", speedRatio: "+this._speedRatio,t+=", targetedAnimations length: "+this._targetedAnimations.length,t+=", animatables length: "+this._animatables),t}}export{V as AnimationGroup,J as TargetedAnimation};
