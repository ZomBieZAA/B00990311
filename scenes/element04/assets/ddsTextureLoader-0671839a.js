import{a2 as O,a3 as g,a4 as U,a5 as P,a6 as Ae,a7 as pe}from"./index-a0afce76.js";const ue=542327876,q=131072,J=512,K=4,Q=64,V=131072;function H(d){return d.charCodeAt(0)+(d.charCodeAt(1)<<8)+(d.charCodeAt(2)<<16)+(d.charCodeAt(3)<<24)}function ye(d){return String.fromCharCode(d&255,d>>8&255,d>>16&255,d>>24&255)}const Z=H("DXT1"),$=H("DXT3"),ee=H("DXT5"),N=H("DX10"),te=113,re=116,ae=2,se=10,Ce=88,S=31,Fe=0,me=1,oe=2,ne=3,T=4,fe=7,W=20,ce=21,Ge=22,he=23,be=24,de=25,Be=26,Re=28,_e=32;class p{static GetDDSInfo(a){const t=new Int32Array(a.buffer,a.byteOffset,S),f=new Int32Array(a.buffer,a.byteOffset,S+4);let o=1;t[oe]&q&&(o=Math.max(1,t[fe]));const i=t[ce],n=i===N?f[_e]:0;let r=0;switch(i){case te:r=2;break;case re:r=1;break;case N:if(n===se){r=2;break}if(n===ae){r=1;break}}return{width:t[T],height:t[ne],mipmapCount:o,isFourCC:(t[W]&K)===K,isRGB:(t[W]&Q)===Q,isLuminance:(t[W]&V)===V,isCube:(t[Re]&J)===J,isCompressed:i===Z||i===$||i===ee,dxgiFormat:n,textureType:r}}static _GetHalfFloatAsFloatRGBAArrayBuffer(a,t,f,o,i,n){const r=new Float32Array(o),l=new Uint16Array(i,f);let e=0;for(let s=0;s<t;s++)for(let A=0;A<a;A++){const c=(A+s*a)*4;r[e]=O(l[c]),r[e+1]=O(l[c+1]),r[e+2]=O(l[c+2]),p.StoreLODInAlphaChannel?r[e+3]=n:r[e+3]=O(l[c+3]),e+=4}return r}static _GetHalfFloatRGBAArrayBuffer(a,t,f,o,i,n){if(p.StoreLODInAlphaChannel){const r=new Uint16Array(o),l=new Uint16Array(i,f);let e=0;for(let s=0;s<t;s++)for(let A=0;A<a;A++){const c=(A+s*a)*4;r[e]=l[c],r[e+1]=l[c+1],r[e+2]=l[c+2],r[e+3]=g(n),e+=4}return r}return new Uint16Array(i,f,o)}static _GetFloatRGBAArrayBuffer(a,t,f,o,i,n){if(p.StoreLODInAlphaChannel){const r=new Float32Array(o),l=new Float32Array(i,f);let e=0;for(let s=0;s<t;s++)for(let A=0;A<a;A++){const c=(A+s*a)*4;r[e]=l[c],r[e+1]=l[c+1],r[e+2]=l[c+2],r[e+3]=n,e+=4}return r}return new Float32Array(i,f,o)}static _GetFloatAsHalfFloatRGBAArrayBuffer(a,t,f,o,i,n){const r=new Uint16Array(o),l=new Float32Array(i,f);let e=0;for(let s=0;s<t;s++)for(let A=0;A<a;A++)r[e]=g(l[e]),r[e+1]=g(l[e+1]),r[e+2]=g(l[e+2]),p.StoreLODInAlphaChannel?r[e+3]=g(n):r[e+3]=g(l[e+3]),e+=4;return r}static _GetFloatAsUIntRGBAArrayBuffer(a,t,f,o,i,n){const r=new Uint8Array(o),l=new Float32Array(i,f);let e=0;for(let s=0;s<t;s++)for(let A=0;A<a;A++){const c=(A+s*a)*4;r[e]=U(l[c])*255,r[e+1]=U(l[c+1])*255,r[e+2]=U(l[c+2])*255,p.StoreLODInAlphaChannel?r[e+3]=n:r[e+3]=U(l[c+3])*255,e+=4}return r}static _GetHalfFloatAsUIntRGBAArrayBuffer(a,t,f,o,i,n){const r=new Uint8Array(o),l=new Uint16Array(i,f);let e=0;for(let s=0;s<t;s++)for(let A=0;A<a;A++){const c=(A+s*a)*4;r[e]=U(O(l[c]))*255,r[e+1]=U(O(l[c+1]))*255,r[e+2]=U(O(l[c+2]))*255,p.StoreLODInAlphaChannel?r[e+3]=n:r[e+3]=U(O(l[c+3]))*255,e+=4}return r}static _GetRGBAArrayBuffer(a,t,f,o,i,n,r,l,e){const s=new Uint8Array(o),A=new Uint8Array(i,f);let c=0;for(let b=0;b<t;b++)for(let u=0;u<a;u++){const y=(u+b*a)*4;s[c]=A[y+n],s[c+1]=A[y+r],s[c+2]=A[y+l],s[c+3]=A[y+e],c+=4}return s}static _ExtractLongWordOrder(a){return a===0||a===255||a===-16777216?0:1+p._ExtractLongWordOrder(a>>8)}static _GetRGBArrayBuffer(a,t,f,o,i,n,r,l){const e=new Uint8Array(o),s=new Uint8Array(i,f);let A=0;for(let c=0;c<t;c++)for(let b=0;b<a;b++){const u=(b+c*a)*3;e[A]=s[u+n],e[A+1]=s[u+r],e[A+2]=s[u+l],A+=3}return e}static _GetLuminanceArrayBuffer(a,t,f,o,i){const n=new Uint8Array(o),r=new Uint8Array(i,f);let l=0;for(let e=0;e<t;e++)for(let s=0;s<a;s++){const A=s+e*a;n[l]=r[A],l++}return n}static UploadDDSLevels(a,t,f,o,i,n,r=-1,l,e=!0){let s=null;o.sphericalPolynomial&&(s=[]);const A=!!a.getCaps().s3tc;t.generateMipMaps=i;const c=new Int32Array(f.buffer,f.byteOffset,S);let b,u,y,C=0,G,R,E,L,k=0,I=1;if(c[Fe]!==ue){P.Error("Invalid magic number in DDS header");return}if(!o.isFourCC&&!o.isRGB&&!o.isLuminance){P.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");return}if(o.isCompressed&&!A){P.Error("Compressed textures are not supported on this platform.");return}let F=c[Ge];G=c[me]+4;let x=!1;if(o.isFourCC)switch(b=c[ce],b){case Z:I=8,k=33777;break;case $:I=16,k=33778;break;case ee:I=16,k=33779;break;case te:x=!0,F=64;break;case re:x=!0,F=128;break;case N:{G+=5*4;let h=!1;switch(o.dxgiFormat){case se:x=!0,F=64,h=!0;break;case ae:x=!0,F=128,h=!0;break;case Ce:o.isRGB=!0,o.isFourCC=!1,F=32,h=!0;break}if(h)break}default:P.Error(["Unsupported FourCC code:",ye(b)]);return}const v=p._ExtractLongWordOrder(c[he]),Y=p._ExtractLongWordOrder(c[be]),j=p._ExtractLongWordOrder(c[de]),le=p._ExtractLongWordOrder(c[Be]);x&&(k=a._getRGBABufferInternalSizedFormat(o.textureType)),E=1,c[oe]&q&&i!==!1&&(E=Math.max(1,c[fe]));const ie=l||0,M=a.getCaps();for(let h=ie;h<n;h++){for(u=c[T],y=c[ne],L=0;L<E;++L){if(r===-1||r===L){const m=r===-1?L:0;if(!o.isCompressed&&o.isFourCC){t.format=5,C=u*y*4;let B=null;if(a._badOS||a._badDesktopOS||!M.textureHalfFloat&&!M.textureFloat)F===128?(B=p._GetFloatAsUIntRGBAArrayBuffer(u,y,f.byteOffset+G,C,f.buffer,m),s&&m==0&&s.push(p._GetFloatRGBAArrayBuffer(u,y,f.byteOffset+G,C,f.buffer,m))):F===64&&(B=p._GetHalfFloatAsUIntRGBAArrayBuffer(u,y,f.byteOffset+G,C,f.buffer,m),s&&m==0&&s.push(p._GetHalfFloatAsFloatRGBAArrayBuffer(u,y,f.byteOffset+G,C,f.buffer,m))),t.type=0;else{const D=M.textureFloat&&(e&&M.textureFloatLinearFiltering||!e),X=M.textureHalfFloat&&(e&&M.textureHalfFloatLinearFiltering||!e),z=(F===128||F===64&&!X)&&D?1:(F===64||F===128&&!D)&&X?2:0;let w,_=null;switch(F){case 128:{switch(z){case 1:w=p._GetFloatRGBAArrayBuffer,_=null;break;case 2:w=p._GetFloatAsHalfFloatRGBAArrayBuffer,_=p._GetFloatRGBAArrayBuffer;break;case 0:w=p._GetFloatAsUIntRGBAArrayBuffer,_=p._GetFloatRGBAArrayBuffer;break}break}default:{switch(z){case 1:w=p._GetHalfFloatAsFloatRGBAArrayBuffer,_=null;break;case 2:w=p._GetHalfFloatRGBAArrayBuffer,_=p._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:w=p._GetHalfFloatAsUIntRGBAArrayBuffer,_=p._GetHalfFloatAsFloatRGBAArrayBuffer;break}break}}t.type=z,B=w(u,y,f.byteOffset+G,C,f.buffer,m),s&&m==0&&s.push(_?_(u,y,f.byteOffset+G,C,f.buffer,m):B)}B&&a._uploadDataToTextureDirectly(t,B,h,m)}else if(o.isRGB)t.type=0,F===24?(t.format=4,C=u*y*3,R=p._GetRGBArrayBuffer(u,y,f.byteOffset+G,C,f.buffer,v,Y,j),a._uploadDataToTextureDirectly(t,R,h,m)):(t.format=5,C=u*y*4,R=p._GetRGBAArrayBuffer(u,y,f.byteOffset+G,C,f.buffer,v,Y,j,le),a._uploadDataToTextureDirectly(t,R,h,m));else if(o.isLuminance){const B=a._getUnpackAlignement(),D=u;C=Math.floor((u+B-1)/B)*B*(y-1)+D,R=p._GetLuminanceArrayBuffer(u,y,f.byteOffset+G,C,f.buffer),t.format=1,t.type=0,a._uploadDataToTextureDirectly(t,R,h,m)}else C=Math.max(4,u)/4*Math.max(4,y)/4*I,R=new Uint8Array(f.buffer,f.byteOffset+G,C),t.type=0,a._uploadCompressedDataToTextureDirectly(t,k,u,y,R,h,m)}G+=F?u*y*(F/8):C,u*=.5,y*=.5,u=Math.max(1,u),y=Math.max(1,y)}if(l!==void 0)break}s&&s.length>0?o.sphericalPolynomial=Ae.ConvertCubeMapToSphericalPolynomial({size:c[T],right:s[0],left:s[1],up:s[2],down:s[3],front:s[4],back:s[5],format:5,type:1,gammaSpace:!1}):o.sphericalPolynomial=void 0}}p.StoreLODInAlphaChannel=!1;class Ue{constructor(){this.supportCascades=!0}loadCubeData(a,t,f,o){const i=t.getEngine();let n,r=!1,l=1e3;if(Array.isArray(a))for(let e=0;e<a.length;e++){const s=a[e];n=p.GetDDSInfo(s),t.width=n.width,t.height=n.height,r=(n.isRGB||n.isLuminance||n.mipmapCount>1)&&t.generateMipMaps,i._unpackFlipY(n.isCompressed),p.UploadDDSLevels(i,t,s,n,r,6,-1,e),!n.isFourCC&&n.mipmapCount===1?i.generateMipMapsForCubemap(t):l=n.mipmapCount-1}else{const e=a;n=p.GetDDSInfo(e),t.width=n.width,t.height=n.height,f&&(n.sphericalPolynomial=new pe),r=(n.isRGB||n.isLuminance||n.mipmapCount>1)&&t.generateMipMaps,i._unpackFlipY(n.isCompressed),p.UploadDDSLevels(i,t,e,n,r,6),!n.isFourCC&&n.mipmapCount===1?i.generateMipMapsForCubemap(t,!1):l=n.mipmapCount-1}i._setCubeMapTextureParams(t,r,l),t.isReady=!0,t.onLoadedObservable.notifyObservers(t),t.onLoadedObservable.clear(),o&&o({isDDS:!0,width:t.width,info:n,data:a,texture:t})}loadData(a,t,f){const o=p.GetDDSInfo(a),i=(o.isRGB||o.isLuminance||o.mipmapCount>1)&&t.generateMipMaps&&Math.max(o.width,o.height)>>o.mipmapCount-1===1;f(o.width,o.height,i,o.isFourCC,()=>{p.UploadDDSLevels(t.getEngine(),t,a,o,i,1)})}}export{Ue as _DDSTextureLoader};
